
--Aug 27, 2021--

Proposed renamings:
	  condition_node.py -> conditions.py
	✓ knowledgebase -> memory
	  predicate_node -> literal
	✓ fact OK 
	Op -> Func
	var OK 


Thinking...
	Right now predicate nodes extract info from Vars when they are constructed...
	Ultimately it would be nice to be able to not just do something like "var op var", and also f(var, var,...) or f(var, f(var,var)) ect. So it seems that 
	it might make more sense for predicate nodes to just be Funcs, and for them
	to be characterized as alpha or not by the number of free variables. Using indexing on "==" is one special detail, and this would need to be turned on or off optionally... maybe that would go into "Context". But it seems that the actual index dictionary needs go into the linked instance, and the Func needs to be marked as indexable (Thought... are beta nodes indexable?)

	There is also the matter of evaluation. Vars and Funcs are both ultimately evaluatable given some binding. For Vars deref_attrs() needs to be executed. 

	Considerations:
		-It would be nice if Conditions were made up of some common thing... like cre.Evaluatable, where it can be executed and it's source is generated on the fly. 

	Evaluatables have in common:
		-A set of variables ('var_base_ptrs?')
		-A thing that happens when all of the variables are grounded 
		-A filter function? Maybe this is just hard coded?
		-A function for generating a string for itself.
		-Metadata?
		-Maybe some way of recasting itself to it's actual type if it is emitted into python. 
		-A way to copy itself... maybe just evaling it's string in python?

	When conditions are linked there is a representation problem. It would be best if the conditions could be rearranged freely. The cleanest thing might just be instead of having Pterms that are linked to Memories, there are normal Condition instances and linked instances? It looks like there is already a copy=True/False option for this. 

	It seems that in all cases a Pterm has enough in common with the proposed cre.Executable that maybe they should be merged. In principle an executable could be linked to a Memory in some contextual manner, that it might make sense for all the link stuff to just be in there. There is also the 'negated' property which could in principle be applied to non-binary values as a sort of existential NOT. Then again maybe Exectuable can just be standin for BasePredicateNodeType.


	There is some common structure like

	Conditions.link_mem(mem).get_matches() -> A list of Match Predicates
	Executable.link_mem(mem).get_matches() -> All Predicates/Tokens representing the execution of the executable.
	Var.link_mem(mem).get).get_matches() -> All values matching the var

	For Conditions some link data is maintained that keeps track of partial matches.
	For Var nothing needs to be maintained, the list of facts are simply returned
	For Func some link data is

	Maybe Predicates should be a specialization of Fact.  

	Predicates are just Pred(name, ...list of member predicates)
	Members should be Facts
	Or alternatively Pred(name,members=x)

	Atoms should also be facts and have .type_name and .value,

	But are Vars facts? Like Equals(boop1.A, boop2.A) -> 
	Vars are executables... maybe facts should also be executables?

	If I wanted a table of things like Equals(boop1.A, boop2.A), then this is more like a table of executables, in which case 

	Could define predicate types like Match=Pred("Match") or just Pred("Match")

	Maybe there is the grounded version of things i.e. Facts + Predicates and then the exectuable versions?

	So if I would like to do something like BOOP(x,y) >> BOOP(str(y),float(x))
	Then BOOP(x,y) both the LHS and RHS are executables.
	Or maybe BOOP(x,y) is really Var(BOOP,"z") & (x:=z.A) & (y:=z.B) >> BOOP(x,y)  
	or Var(BOOP,"z") >> BOOP(str(z.B), float(z.A))

	Is this invertable... I guess this is it's own inverse? But how do I find that?
	I guess the constructor BOOP would have an inversion BOOP(u,v) >> u & v and then str and float would be inverses of each other so BOOP(u,v)


	Var(str,"x") & Var(float,"y") & Var()





Example:
c = (
	Var(f8, "A") &
	Var(f8, "B") &
	(B+1 < A) & (A==1) & F(B)
)



--Aug 28, 2021--

CREBase(cre_type : u8)

What if there are
	Executables(base_var_ptrs : *Var[:], exec_func_addr : *Func):
		-Var
		-Func
		-Conditions
		-Rule(lhs: conditions, rhs : executable)
	Facts:
		-Normal Fact structs
		-Grounding (exec : cre.Executable, args : *Fact[:], value : Cre.Atom)
		-Predicate (name : str, args : *Fact[:])
		-Atom (type: str, value : any[float,str,list[any]])

Memories only consist of Facts. The flattened working memory would only consist of groundings. 

Executables all have base_var_ptrs, and an exec_func_addr



Example Rules:

#For all boops 'x' declare another boop with B=x.B+1
Var(BOOP, "x") >> BOOP(x.A,x.B+1)


#Define Predicate
Pred("GT")
(
	Var(BOOP,"x") & Var(BOOP,"y") & 
	(x.B <= (y.B + 1))
) >> (
	GT(x,y)
)


#Retract 
(
	Var(BOOP,"x") & Var(BOOP,"y") & 
	(x.B <= (y.B + 1))
) >> (
	NOT(x) 
)


Note: A var can be existentially NOT'ed, an executable can be negated
Potential qualifiers for an executable:
	TRUTHY(1), FALSEY(-1), VALUE(0)

If &/| are applied to put it in a conditions object then it should be TRUTHY 
If ~ is applied then it should be FALSEY
Otherwise it is VALUE 

When a FuncComp is &/| then it should be flattened in order to define an exec_func

Under what contexts does exec_func get applied?
	1. When the func is used as a literal term that we want to check a match against in which case we would want to just pass it pointers or Fact instances. In this case what do we do with the func's muted exceptions and check function?
	2. When we use it during get_matches and want to filter a partial match. In this case it needs to be wrapped in some loop, and it should really just return a boolean value. 
	3. When the Executable is used to compute groundings, and we want to use exec_func to produce the value of the grounding. 
	4. When the Executable shows up on the RHS of a Rule and we want to declare whatever comes out of the exec_func 

For cases 1 & 2 the exec can just be wrapped to be Truthy if it isn't already.


For cases 1 & 2 the type of the exec can be anything, in this context it probably makes sense to for exec_func to poop out an Atom if it doesn't already poop out a proper Fact. 

There is also the consideration that in this case we can have NOT(x) kinds of terms. How do we unify this with the Executable type? NOT only makes sense in the context of Vars and would in reality be wrapped in a Conditions object. So the Conditions object could just know that NOT(x) should be treated as a retraction at runtime. 

We need a way of declaring named facts using this shorthand. In principle this means that every fact should be able to take name as a kwarg, and have a name slot. 

There is also the runtime consideration that FactCtor(Var, Var,...) is actually an Op of sorts... Maybe I already handled this 


The first step to all of this is probably to make conditions work with Exectuables instead of with 

TODO:
[] Make a common cre.Executables supertype for Ops, Vars, and Conditions
[] Make Conditions work off of executables 
[] Make All facts capable of taking a name, except maybe not Atoms?


--Aug 29, 2021--

Going to simply reorganize Conditions so that it builds a DNF of Literals (i.e. an Op + other stuff). The main DNF will just be a List(List(Literal)), but at initialization it will be reorganized such that every conjunct 


--Sep 1, 2021--

We need to be able to reconstruct the python object for an Op instance. The most straight forward way would probably be to reapply it's __class__. This could either be stored in the cre_context() and retrieved by some unique repr of the Op, or somehow stored in the struct or datamodel of the Op. 


Op class:
	repr: Op[Add](signature=float64(float64,float64), members={})
	str: ...

Op:
	repr: Add(Add(a:float64, b:float64), c:float64) -> float64
	str : ((a + b) + c)
	expr_template : Add(Add({0},{1}),{2})
	shorthand_template : (({0} + {1}) + {2})
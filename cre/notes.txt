
--Aug 27, 2021--

Proposed renamings:
	  condition_node.py -> conditions.py
	✓ knowledgebase -> memory
	  predicate_node -> literal
	✓ fact OK 
	Op -> Func
	var OK 


Thinking...
	Right now predicate nodes extract info from Vars when they are constructed...
	Ultimately it would be nice to be able to not just do something like "var op var", and also f(var, var,...) or f(var, f(var,var)) ect. So it seems that 
	it might make more sense for predicate nodes to just be Funcs, and for them
	to be characterized as alpha or not by the number of free variables. Using indexing on "==" is one special detail, and this would need to be turned on or off optionally... maybe that would go into "Context". But it seems that the actual index dictionary needs go into the linked instance, and the Func needs to be marked as indexable (Thought... are beta nodes indexable?)

	There is also the matter of evaluation. Vars and Funcs are both ultimately evaluatable given some binding. For Vars deref_attrs() needs to be executed. 

	Considerations:
		-It would be nice if Conditions were made up of some common thing... like cre.Evaluatable, where it can be executed and it's source is generated on the fly. 

	Evaluatables have in common:
		-A set of variables ('var_base_ptrs?')
		-A thing that happens when all of the variables are grounded 
		-A filter function? Maybe this is just hard coded?
		-A function for generating a string for itself.
		-Metadata?
		-Maybe some way of recasting itself to it's actual type if it is emitted into python. 
		-A way to copy itself... maybe just evaling it's string in python?

	When conditions are linked there is a representation problem. It would be best if the conditions could be rearranged freely. The cleanest thing might just be instead of having Pterms that are linked to Memories, there are normal Condition instances and linked instances? It looks like there is already a copy=True/False option for this. 

	It seems that in all cases a Pterm has enough in common with the proposed cre.Executable that maybe they should be merged. In principle an executable could be linked to a Memory in some contextual manner, that it might make sense for all the link stuff to just be in there. There is also the 'negated' property which could in principle be applied to non-binary values as a sort of existential NOT. Then again maybe Exectuable can just be standin for BasePredicateNodeType.


	There is some common structure like

	Conditions.link_mem(mem).get_matches() -> A list of Match Predicates
	Executable.link_mem(mem).get_matches() -> All Predicates/Tokens representing the execution of the executable.
	Var.link_mem(mem).get).get_matches() -> All values matching the var

	For Conditions some link data is maintained that keeps track of partial matches.
	For Var nothing needs to be maintained, the list of facts are simply returned
	For Func some link data is

	Maybe Predicates should be a specialization of Fact.  

	Predicates are just Pred(name, ...list of member predicates)
	Members should be Facts
	Or alternatively Pred(name,members=x)

	Atoms should also be facts and have .type_name and .value,

	But are Vars facts? Like Equals(boop1.A, boop2.A) -> 
	Vars are executables... maybe facts should also be executables?

	If I wanted a table of things like Equals(boop1.A, boop2.A), then this is more like a table of executables, in which case 

	Could define predicate types like Match=Pred("Match") or just Pred("Match")

	Maybe there is the grounded version of things i.e. Facts + Predicates and then the exectuable versions?

	So if I would like to do something like BOOP(x,y) >> BOOP(str(y),float(x))
	Then BOOP(x,y) both the LHS and RHS are executables.
	Or maybe BOOP(x,y) is really Var(BOOP,"z") & (x:=z.A) & (y:=z.B) >> BOOP(x,y)  
	or Var(BOOP,"z") >> BOOP(str(z.B), float(z.A))

	Is this invertable... I guess this is it's own inverse? But how do I find that?
	I guess the constructor BOOP would have an inversion BOOP(u,v) >> u & v and then str and float would be inverses of each other so BOOP(u,v)


	Var(str,"x") & Var(float,"y") & Var()





Example:
c = (
	Var(f8, "A") &
	Var(f8, "B") &
	(B+1 < A) & (A==1) & F(B)
)



--Aug 28, 2021--

CREBase(cre_type : u8)

What if there are
	Executables(base_var_ptrs : *Var[:], exec_func_addr : *Func):
		-Var
		-Func
		-Conditions
		-Rule(lhs: conditions, rhs : executable)
	Facts:
		-Normal Fact structs
		-Grounding (exec : cre.Executable, args : *Fact[:], value : Cre.Atom)
		-Predicate (name : str, args : *Fact[:])
		-Atom (type: str, value : any[float,str,list[any]])

Memories only consist of Facts. The flattened working memory would only consist of groundings. 

Executables all have base_var_ptrs, and an exec_func_addr



Example Rules:

#For all boops 'x' declare another boop with B=x.B+1
Var(BOOP, "x") >> BOOP(x.A,x.B+1)


#Define Predicate
Pred("GT")
(
	Var(BOOP,"x") & Var(BOOP,"y") & 
	(x.B <= (y.B + 1))
) >> (
	GT(x,y)
)


#Retract 
(
	Var(BOOP,"x") & Var(BOOP,"y") & 
	(x.B <= (y.B + 1))
) >> (
	NOT(x) 
)


Note: A var can be existentially NOT'ed, an executable can be negated
Potential qualifiers for an executable:
	TRUTHY(1), FALSEY(-1), VALUE(0)

If &/| are applied to put it in a conditions object then it should be TRUTHY 
If ~ is applied then it should be FALSEY
Otherwise it is VALUE 

When a FuncComp is &/| then it should be flattened in order to define an exec_func

Under what contexts does exec_func get applied?
	1. When the func is used as a literal term that we want to check a match against in which case we would want to just pass it pointers or Fact instances. In this case what do we do with the func's muted exceptions and check function?
	2. When we use it during get_matches and want to filter a partial match. In this case it needs to be wrapped in some loop, and it should really just return a boolean value. 
	3. When the Executable is used to compute groundings, and we want to use exec_func to produce the value of the grounding. 
	4. When the Executable shows up on the RHS of a Rule and we want to declare whatever comes out of the exec_func 

For cases 1 & 2 the exec can just be wrapped to be Truthy if it isn't already.


For cases 1 & 2 the type of the exec can be anything, in this context it probably makes sense to for exec_func to poop out an Atom if it doesn't already poop out a proper Fact. 

There is also the consideration that in this case we can have NOT(x) kinds of terms. How do we unify this with the Executable type? NOT only makes sense in the context of Vars and would in reality be wrapped in a Conditions object. So the Conditions object could just know that NOT(x) should be treated as a retraction at runtime. 

We need a way of declaring named facts using this shorthand. In principle this means that every fact should be able to take name as a kwarg, and have a name slot. 

There is also the runtime consideration that FactCtor(Var, Var,...) is actually an Op of sorts... Maybe I already handled this 


The first step to all of this is probably to make conditions work with Exectuables instead of with 

TODO:
[] Make a common cre.Executables supertype for Ops, Vars, and Conditions
[] Make Conditions work off of executables 
[] Make All facts capable of taking a name, except maybe not Atoms?


--Aug 29, 2021--

Going to simply reorganize Conditions so that it builds a DNF of Literals (i.e. an Op + other stuff). The main DNF will just be a List(List(Literal)), but at initialization it will be reorganized such that every conjunct 


--Sep 1, 2021--

We need to be able to reconstruct the python object for an Op instance. The most straight forward way would probably be to reapply it's __class__. This could either be stored in the cre_context() and retrieved by some unique repr of the Op, or somehow stored in the struct or datamodel of the Op. 


Op class:
	repr: Op[Add](signature=float64(float64,float64), members={})
	str: ...

Op:
	repr: Add(Add(a:float64, b:float64), c:float64) -> float64
	str : ((a + b) + c)
	expr_template : Add(Add({0},{1}),{2})
	shorthand_template : (({0} + {1}) + {2})


cases:
	1) Add(Var(float,"x"),Var(float,"y"))
	-Should produce a new instance of Add with the new Vars, and specialize Add if necessary.
	2) Add(Add(Var(float,"x"),Var(float,"y")), Var(float,"z"))
	-As above for the inner term, then make an OpComp that is flattened into an op
	3) Add(1,2)
	-Should specialize Add if needed and apply call()
	4) Add(1,Var(f8,"y"))
	-Should specialize Add if needed, make a new OpComp and then flatten it into an Op


To handle all of these we should make a resolve_return_type function that can take a Var, Op, or Constant 


TODO:
	[x] Fix bug with variables names not propogating w/ Op_comp
	[x] Make test cases for untypedOp

	[x] Make dereffing Vars need to be compiled
	[x] Implement repr() for Op


--Sep 3, 2021--

Next steps:
	[x] Overload <, >, <=, >=, ==, +, * , -, /
	[] Make sure conditions str/repr properly <-- probably can be the same except that repr should probably reveal that it is a member of the Conditions class and reveal any active mem_link.
	[] Define filter_op... the rest will probably just work...

---Sep 4, 2021---

Thoughts... I've gone back and forth between keeping alpha and beta bits seperate. It seems uncessary now that everything just uses literals/ops. It would make sense to just have the dnf be a list of lists,
and then at initialization things would be reordered into a structure with order:
	Dim 0: slot = argmax(left_var_num, right_var_num,...)
	Dim 1: slot = 
		(Indexed alphas < alphas) < (betas) < ...


distr_dnf:
Bins for each Var
Alphas need to be in their own bin
betas need to be in their own bin
After alphas are taken care of then they need to be passed to various betas.
In principle this means finding connected components among the betas
 1) ? each conjunct. <----
 2) ? each dnf?
And then picking some order that they should be checked.

Dictionaries are probably going to need to be the main data structure.
If on the left a dictionary is provided with keys [a_i,b_j,c_k]
and on the right a dictionary with keys [d_l,] is provided
then all [a,b,c] x [d,] should be checked for d < b and the output dictionary of passing values should be of [a,b,c,d]. Now how can we keep this result and only check diffed facts. In this instance we only care
about changes in b's and d's. The nodes being inputted into this
node should probably...

We need to keep track of all facts that have changed since we last updated,
so if the Conditions object's queue is just a bunch of FIDs that have changed then we need a way of querying these FIDs to see whether the current literal needs updating. This goes for the FIDs of facts that are only indirectly involved through dereferencing. This means we probably need to either:
	1) Not embed the dereferences in the op, and call deref_attrs 
	2) Keep some meta-data about the dereferences... which in practice means computing the intermediates anyway.

So then there really needs to be a 'depends' dictionary of FID->??

Maybe there only needs to be a depends dictionary and the rest is just vectors. For example a 2d vector is passed for [a,b,c] x [d,] and then [a,b,c,d] is a new vector. Along the way the 'depends' dictionary is filled with the FIDs for all d's and b's (plus FIDs for dereferences) as keys and the values are the indicies of the relevant values within the left, right and resultant vectors. In the case of retractions these vectors would need to be filled with zeros and the missing spots remembered.

Now on a retraction:
	an FID is put in the change queue. At the first node it is checked against the 'depends' (if the FID doesn't have an attr_id then the relevant one should be assumed), the output vector that the depends points to should be updated with the change. (Seems like we probably don't need to edit the input vectors after all, since they would have already been altered by the previous node). In the next nodes we do the same thing... checking the entire change queue against the 'depends' of the node... If a change in left makes left + right fail then we need to remove right from 'depends' as well.

	So probably in order for 'depends' to clean itself up properly it should be something like (output_index, ...FIDs to remove from self)... but maybe this doesn't work because other Left FID could still be needed by another output. Maybe 'depends' should be a nested dict(dict())???

In the original RETE everything works by propogation, the set of matches are literally passed along... does that not work here? What is missing...

The question is when something goes missing how to we remove only that thing from the output of a node... maybe we just search for it?

This is kind of the same problem I was having without even doing it this way, and the solution involved keeping around a consistency matrix... which probably would work fine here too... just the outputs would be different. 

Okay so looking back it seems that there is a truth_values matrix and a consistency matrix and the output is created by finding the true points in the truth table.

The consistency table is certainly convenient in some ways... Although it seems probably too intimately connect to the left/right fact vector sizes. So how can we make for a more minimal data structure...

At the end of the day the ONLY thing a node needs to achieve is consistency between it's inputs and output. So we can probably achieve something similar to the consistency matrix by just keeping two 'depends' dictionaries for the left and right... where I guess the keys are just the same as the inputs. This gets us back to passing around dictionaries. 

What if we did this. The Conditions object passes the items in the change queue along to their respective alpha nodes. The alpha nodes maintain their own change queues (which are maybe just cleared after each update) and when a downstream nodes goes to update, it rechecks the pairs in the union of left_change * right_all and left_all * right_changes. As a result of rechecking we might need to add or remove items ->  would alter the current node's change queue. 

Should node change queues consist of indicies or [...FIDs]? Indicies only work if we're using holey vectors.

To really update the outputs we either need to know where each output goes in an array or we need to just use a set/dictionary and add/del keys.

We'll need to use dictionaries. So then the change queue is just a dictionary of added things and removed things. For removed things we need to do the usual inner product and just take out any that are already in the output. For added things we do the same but only add them in if they evaluate to true.


-- Sep 6, 2021 --

Some thoughts... if x.B.B.A < y.B.A then one match to this depends on 10 (really 12) possible changes.

	-- Fact Retractions --
	-retraction of x
	-retraction of y

	-- Deref retractions / Modifications --
	-modification of x.B
	-retraction of x.B
	-modification of x.B.B
	-retraction of x.B.B
	-modification of y.B
	-retraction of y.B

	-- Head modifications --
	-modification of x.B.B.A
	-modification of y.B.A

	--- These two can be baked into retraction of x/y ---
	-x being retracted from the output of left
	-y being retracted from the output of right

Our 'depends' dictionary would need to have all of these possibilities
as keys and the values would need to be a list of outputs + the other keys that are depended upon.

If an output is invalidated then we need to remove all of its depends, but not any that are also part of another output. So we need some kind of refcounting solution.

So DependencyEntry would have:
	"count" : int 
	"outputs" : List() ???


This just seems like a ton of overhead... but maybe it's necessary?
The overhead for just one node might be more than conservatively rechecking everything.


Thought... how are things simplified if only considering fact retractions, declarations and head modifications?

What if every output kept track of it's own list of nodes + outputs that need to be retracted or rechecked. A node can edit this list, and signal a change. So if it is retracted all of its downstream dependencies are retracted. Is this that different from the 'depends' dict? A little bit because it reduces...

What if the fact itself keeps track of things that depend on it. So when a modification occurs it can signal a checked. 




'depends' = idrec -> array of pointers to OutputEntries()
	the output entries have other idrecs... we don't need to clean them
	out because the OutputEntry instance can just be marked as invalid

ConditionNode
	"inputs" : ListType(??),
    "output" : Vector(*OutputEntryType),
    "arg_indicies" : i8[::1],
    "literal" : LiteralType,
	"t_ids" : i8[::1],
	"depends" : DictType(i8, ListType(OutputEntryType))
	"fail_depends" : DictType(i8, i8)


OutputEntry
	"is_valid" : u1,
	"index" : i8,
	"f_ids" : u8[::1], #maybe u4[::1]
	"depends_idrecs" : u8[::1]

When update is called:
	1) look through the .mem's change_queue and check for
		(idrec ~ left_t_id | idrec ~ right_t_id)

		Also go through the the change queues of the inputs and use the equivalent idrecs for the node that would be created from the f_ids of the changed OutputEntries.

		Accumulate these changes... clobber declarations/retractions chronologically. Do on .mem first then the inputs.

		#if any of the .mem ones are in deref_fails then go to the OutputEntry associated with the input and add it to the appropriate left/right change set.


for each change:
	if(change ~ DEC):
		try left_changes * all_right
		try right_changes * all_left
		
		if(!passes because of deref):
			add to deref_fails

		if(passes):
			make the output entry
			add fids encountered into depends
			self.changed_entries.append((DEC, output_entry))

	else:
		if(idrec in depends):
			for output_entry in depends[idrec]:
				passes = ?passes(output_entry) if(change ~ MOD) else False
				if(not passes):
					if(output_entry.is_valid):
						outputs.remove(output_entry)
						output_entry.is_valid = False

					self.changed_entries.append((RET,output_entry))
					


Maybe it makes more sense to treat deref failures per input, so for example for the left inputs we try to deref everything and we see where it stops.  


So,
	left_deref_depends : idrec -> List(DerefRecord)
	right_deref_depends : idrec -> List(DerefRecord)

	when one of these changes we need to reattempt to find the fid of the head fact.

	so now once all of these get processed we should only have to worry about base_fids in the depends dict?

	From these we should be able to come up with a 
	'left_deref_records' and 'right_deref_records' and in the case that something changes (a deref chain now succeeds/fails/alters it's head) there is now an effective set of left_changes and right_changes which are just the base fids.


Psuedo code round 2:

ConditionNode
	"inputs" : ListType(??),
    "output" : Vector(*OutputEntryType),
    "arg_indicies" : i8[::1],
    "literal" : LiteralType,
	"deref_t_ids" : i8[::1],
	"depends" : DictType(i8, ListType(OutputEntryType))
	"deref_depends : List(DictType(i8, ListType(DerefRecord)))"
	"deref_consistencies" : List(vector(i8))"


OutputEntry
	"is_valid" : u1,
	"index" : i8,
	"f_ids" : u8[::1], #maybe u4[::1]
	"depends_idrecs" : u8[::1]

DerefRecord = {
	"is_valid" : u1,
	"consistency_index" : u1,
	"fids" : i8[::1],
}



for idrec in self.mem.change_queue:
	chg_typ, f_id = idrec
	for i in range(n_args):
		if(f_id in deref_depends[i]):
			
			if(chg_typ == DEC):

			else:
				deref_record = deref_depends[i][f_id]
				deref_consistencies[i].remove([deref_record.consistency_index]




Maybe it's better to just have a seperate DerefNode that lives inside each alpha/beta node. 

So DerefNode takes in the .output of all .inputs and produces a change_set that can be used by the alpha/beta node.

Cases:
	r1) retract(z)
	r2) retract(z.B)

	m1) modify(z.B)
	m2) modify(z.B.A)

	d) declare(z)

	//declare(z.B) <-This isn't possible. It would either be linked at instantiation or change with a subsequent modify.

Two things need to be up to date after an update:
	1) .outputs : Vector(*OutputEntry),
	2) .retracted_inds: Vector(i8) 
	3) .inds_of_diffs : Vector(i8) <- Indicies that need to be rechecked downstream


d:
	Only triggered by changes in .input.inds_of_diffs
	- .input.output.add(input.inds_of_diffs) needs to be in self.output
	- if .retracted_inds was nonempty then there should be one fewer
	- whatever index was used when added needs to be in .inds_of_diffs
	Should ignore other declarations

r1:
	triggered by changes in .input.inds_of_diffs?
	- 







--- Sept 7 ----

It dawned on me that there is potentially a lot of duplicate checking in normal RETE. For example if I am checking (b < c) then the matches of for instance a beta check (a < b) previous in the graph might produce multiple matches to the same b. We could alternative keep around data structures like: 

{b -> [a1,a2,a3]}
{a -> [b1,b2,b3]}

Probably only need one or the other, although the other one potentially double as a 'depends' dictionary at least for base declarations/retractions.

Reconstructing the match would then involve rebuilding the matches backwards through a set of nodes marked as resolution nodes... 











 

